<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  The Velociraptor Registry Hunter Project
  #

This repository contains Registry Hunting targets to quickly hunt
through the Windows registry.
To read more about this project, see https://github.com/Velocidex/registry_hunter
As DFIR practitioners, the Windows registry is a treasure trove of
information. The Windows registry stores information about system
configuration and therefore we can use it to understand what software
was installed, how it was configured and hunt for misconfiguration or
deliberate compromises to achieve attacker persistence."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="http://registry-hunter.velocidex.com/docs/registry_hunter/"><meta property="og:site_name" content="Velociraptor Registry Hunting"><meta property="og:title" content="Velociraptor Registry Hunter"><meta property="og:description" content="The Velociraptor Registry Hunter Project # This repository contains Registry Hunting targets to quickly hunt through the Windows registry.
To read more about this project, see https://github.com/Velocidex/registry_hunter
As DFIR practitioners, the Windows registry is a treasure trove of information. The Windows registry stores information about system configuration and therefore we can use it to understand what software was installed, how it was configured and hunt for misconfiguration or deliberate compromises to achieve attacker persistence."><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><title>&lt;span class="icon">
&lt;i class="fa-solid fa-desktop">&lt;/i>
&lt;/span>
Velociraptor Registry Hunter
| Velociraptor Registry Hunting</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=http://registry-hunter.velocidex.com/docs/registry_hunter/><link rel=stylesheet href=/book.min.f4bc2b0f80cbd784c51fa6123079c0ec4d90946148cb1cc5e0279ca61d81a19d.css integrity="sha256-9LwrD4DL14TFH6YSMHnA7E2QlGFIyxzF4Cecph2BoZ0=" crossorigin=anonymous><link rel=alternate type=application/rss+xml href=http://registry-hunter.velocidex.com/docs/registry_hunter/index.xml title="Velociraptor Registry Hunting"><script src=/js/jquery-3.3.1.min.js?1703133391></script><link href=https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css?1703133392 rel=stylesheet><link href=/css/theme.css rel=stylesheet><link href=//cdn.datatables.net/2.3.0/css/dataTables.dataTables.min.css rel=stylesheet><script src=//cdn.datatables.net/2.3.0/js/dataTables.min.js></script><link href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/yaml.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/featherlight/1.7.13/featherlight.min.js integrity="sha512-0UbR6HN0dY8fWN9T7fF658896tsPgnbRREHCNq46J9/JSn8GonXDZmqtTc3qS879GM0zV49b9LPhdc/maKP8Kg==" crossorigin=anonymous referrerpolicy=no-referrer></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/featherlight/1.7.13/featherlight.min.css integrity="sha512-56GJrpSgHk6Mc9Fltt+bQKcICJoEpxtvozXPA5n5OT0rfWiqGlJmJCI/vl16kctf/0XbBloh03vl7OF2xFnR8g==" crossorigin=anonymous referrerpolicy=no-referrer><script>$(document).ready(function(){$(".json-renderer").each(function(){try{data=JSON.parse($(this).text()),$(this).jsonViewer(data,{collapsed:!0,rootCollapsable:!1})}catch{}}),$(".datatable").each(function(){new DataTable(this,{paging:!0})}),$(".scroll-datatable").each(function(){let e=$(this),t=new DataTable(this,{paging:!1,scrollY:200})})})</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Velociraptor Registry Hunting</span></a></h2><ul><li><a href=/docs/registry_hunter/ class=active><span class=icon><i class="fa-solid fa-desktop"></i>
</span>Velociraptor Registry Hunter</a><ul><li><a href=/docs/registry_hunter/develop/><span class=icon><i class="fa-solid fa-desktop"></i>
</span>Developing</a><ul></ul></li></ul></li><li><a href=/docs/rules/><span class=icon><i class="fa-solid fa-book"></i>
</span>Rules</a><ul></ul></li><li><a href=/docs/github/><span class=icon><i class="fa-brands fa-github"></i>
</span>Github</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3><span class=icon><i class="fa-solid fa-desktop"></i>
</span>Velociraptor Registry Hunter</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#velociraptor-artifacts>Velociraptor Artifacts</a></li><li><a href=#some-problems-with-the-above-approach>Some problems with the above approach</a></li><li><a href=#what-do-other-tools-do>What do other tools do?</a></li><li><a href=#so-what-do-we-actually-want>So what do we actually want?</a></li><li><a href=#the-registry-hunter>The Registry Hunter</a><ul><li><a href=#remapping-the-registry-hives>Remapping the registry hives</a></li><li><a href=#importing-the-latest-version-of-the-registry-hunter-artifact>Importing the latest version of the Registry Hunter artifact</a></li><li><a href=#collecting-the-artifact>Collecting the artifact</a></li><li><a href=#the-rule-format>The Rule format</a></li></ul></li><li><a href=#presenting-the-results-of-the-analysis>Presenting the results of the analysis</a></li><li><a href=#current-categories>Current Categories</a></li><li><a href=#conclusions>Conclusions</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=the-velociraptor-registry-hunter-project>The Velociraptor Registry Hunter Project
<a class=anchor href=#the-velociraptor-registry-hunter-project>#</a></h1><p>This repository contains Registry Hunting targets to quickly hunt
through the Windows registry.</p><p>To read more about this project, see <a href=https://github.com/Velocidex/registry_hunter>https://github.com/Velocidex/registry_hunter</a></p><p>As DFIR practitioners, the Windows registry is a treasure trove of
information. The Windows registry stores information about system
configuration and therefore we can use it to understand what software
was installed, how it was configured and hunt for misconfiguration or
deliberate compromises to achieve attacker persistence.</p><p>There are many tools out there to extract forensically relevant
information from the registry. However, the problem is challenging:</p><ol><li><p>The registry contains thousands of keys and values. While it is
possible to manually examine relevant keys and values this is
extremely time consuming and error prone.</p></li><li><p>Some of the values are encoded in non-obvious ways. For example, it
is common for registry values to store times encoded as Unix epoch
integers, Windows File Time integers or even encoded into binary
encoded blobs. Since the registry is really intended for machine
consumption it is not always easy to parse human readable
information out of the values.</p></li><li><p>Often relevant information is spread across a number of keys and
values. For a human examiner to make sense of the information, the
information needs to be collected into a single entity.</p></li><li><p>Registry information does not have contextually significant
explanation about what the values actually mean, and how
significant they are in an investigation. Although this is left to
the experience of the examiner, it is useful to attach some
comments or description to the analysis.</p></li></ol><h2 id=velociraptor-artifacts>Velociraptor Artifacts
<a class=anchor href=#velociraptor-artifacts>#</a></h2><p>Velociraptor has been used to extract values from the windows registry
for a long time. In Velociraptor the registry is accessible via the
<code>registry</code> accessor (to access the registry via the APIs) and the
<code>raw_reg</code> accessor to parse raw registry hives. See <a href=https://docs.velociraptor.app/docs/forensic/filesystem/#the-registry-accessor>The Registry
Accessor</a> to read more about how Velociraptor accesses the registry.</p><p>This allows Velociraptor to use simple <code>glob()</code> expressions to find
keys and values in the registry. For example in the
<a href=https://docs.velociraptor.app/artifact_references/pages/windows.registry.sysinternals.eulacheck.html>Windows.Registry.Sysinternals.EulaCheck</a> artifact we can search for evidence of running <code>Sysinternals tools</code>. The following is a simplified query:</p><pre tabindex=0><code class=language-vql data-lang=vql>SELECT OSPath[-2] as ProgramName,
    lookupSID(sid=OSPath[1]) AS Username,
    OSPath.Dirname as Key,
    Mtime AS TimeAccepted,
    Data.value  AS EulaAccepted
FROM glob(globs=&#39;&#39;&#39;HKEY_USERS\*\Software\Sysinternals\*\EulaAccepted&#39;&#39;&#39;,
          accessor=&#39;registry&#39;)
</code></pre><p>This artifact works pretty well:</p><ol><li>The artifact zeros in on the relevant values in the registry
without user intervention - the investigator does not have to know
or care where the relevant <code>Sysinternal Eula</code> values are.</li><li>The artifact decodes the values to interpret the user action (did
the user accept the EULA?) and also maps the SID back to a
username.</li><li>The artifact contains sufficient human description to elicit
action - what does it mean if a user accepted the EULA? Is this
fact relevant to the investigation?</li></ol><p>While very effective, over time the number of registry artifacts in
Velociraptor has grown. From the point of view of the investigator it
is becoming more difficult to use:</p><ul><li>We need to remember many smaller artifacts that target the registry
to collect.</li><li>We need to consider the output separately for each artifact.</li></ul><h2 id=some-problems-with-the-above-approach>Some problems with the above approach
<a class=anchor href=#some-problems-with-the-above-approach>#</a></h2><p>You will notice that the above artifact searches the <code>NTUSERS</code>
hive. This hive contains each user&rsquo;s <code>ntuser.dat</code> file which is
mounted when the user logs in.</p><p>While the artifact works very well for currently logged users, it will
be unable to see any users who are currently not logged into the
system! This can cause a lot of evidence to be missed.</p><p>The problem here is that the registry is composed of different hives
and some hives may be mounted at different times. However, when we
analyze the registry we often want to access all hives!</p><p>When we use the API to access the registry, we could be missing hives
that are not currently mounted. Conversely when we use raw registry
parsing to only look at hive files we will be missing volatile keys
that are not always written to the hives.</p><p>In the specific case of <code>Windows.Registry.Sysinternals.EulaCheck</code> the
artifact also offers an alternate analysis method which looks at the
<code>ntuser.dat</code> files themselves. However this has to be added
specifically for each artifact.</p><h2 id=what-do-other-tools-do>What do other tools do?
<a class=anchor href=#what-do-other-tools-do>#</a></h2><p>Investigator focused tools typically attempt to analyze the whole
registry. For example, <code>regripper</code> or <code>RECmd/Registry Explorer</code> present a
GUI to the registry and simply tag keys and values based on their
significance. This is very convenient for the investigator, as they
only need to run the analysis once then examine the output manually.</p><p>While this is effective for analyzing a small number of machines, it
can not be easily scaled to large hunts on thousands of machines where
we need a more machine readable output.</p><p>The <code>RECmd Batch</code> project is an interesting idea forward. It started
off as an automated Batch File to drive <code>RECmd/Registry Explorer</code>
analysis by only collecting relevant keys/value and tagging these with
category and description labels.</p><p>Here is an example <code>RECmd Batch</code> rule corresponding to the above artifact:</p><pre tabindex=0><code>    -
        Description: Sysinternals
        HiveType: NTUSER
        Category: Installed Software
        KeyPath: SOFTWARE\Sysinternals\*
        ValueName: EulaAccepted
        Recursive: false
        Comment: |
           Displays all SysInternals Tools that had the EULA accepted,
           indicating either execution of the tool or the Registry values
           were added intentionally prior to execution
</code></pre><p>This rule attaches a description and category to the <code>EulaAccepted</code>
value and also includes how to find it. There is also a useful comment
to drive the investigator towards assessing the importance of these
findings.</p><p>The <code>RECmd Batch</code> format also has some basic registry interpretation
built in (such as <code>FILETIME</code> to interpret timestamps), but more
complex interpretation is deferred to <code>Registry Plugins</code> which are <code>C# programs</code> specifically designed to interpret more complex keys or
values. The use of <code>C#</code> makes writing registry plugins less accessible
and more complex.</p><h2 id=so-what-do-we-actually-want>So what do we actually want?
<a class=anchor href=#so-what-do-we-actually-want>#</a></h2><p>We wanted to have a single artifact that hunts the entire registry
quickly and efficiently:</p><ol><li>Combining all the specific registry based artifacts into a single
one so investigators don&rsquo;t have to remember all the different
artifacts - a single shot collection should be all that is needed
to cover all registry based evidence.</li><li>All relevant information should be grouped by <code>Category</code> and
<code>Description</code>. The artifact should make it easy to zero in on
specific categories depending on the investigator&rsquo;s needs.</li><li>Ideally group together related key/values for quick analysis - this
is needed to remove the cognitive load on the investigator in
reviewing thousands of related values.</li><li>The artifact should be collected in different contexts:<ul><li>On a live system using the registry API.</li><li>Offline on a collection of Registry Hive Files</li><li>Automatically take care of subtleties such as <code>NTUser.dat</code> mounts
(as described about).</li></ul></li></ol><p>This is what the registry hunter is all about!</p><h2 id=the-registry-hunter>The Registry Hunter
<a class=anchor href=#the-registry-hunter>#</a></h2><p>The Registry Hunter project is maintained at
<a href=https://github.com/Velocidex/registry_hunter/>https://github.com/Velocidex/registry_hunter/</a> and contains a compiler
that combines a set of <code>Rules</code> into a final artifact. This allows
users to contribute specific rules targeting specific keys and value
in the registry.</p><h3 id=remapping-the-registry-hives>Remapping the registry hives
<a class=anchor href=#remapping-the-registry-hives>#</a></h3><p>To make it easier to write Registry Hunter rules and also to make it
easier to apply those rules in different situations, we want to
present a unified view of the registry to rule authors. The rule
authors should not need to care about if a registry hive is mounted or
available.</p><p>In recent versions, Velociraptor implements a powerful mechanism to
<code>remap</code> accessors within the name space. You can read about <a href=https://docs.velociraptor.app/docs/forensic/filesystem/remapping/>Remapping
Accessors</a> to
understand how this is done.</p><p>The Registry Hunter artifact will map the relevant hives into the
<code>registry</code> accessor namespace using a number of different strategies.</p><p>The below diagram illustrates how the remapping works with the <code>Raw Hives</code> strategy. In this configuration, the <code>registry</code> accessor is
remapped to using all the raw registry hives and does not use the API
at all.</p><p><figure id=5c56ae3b4e9a5a42c2780334b6a8c68c><div data-featherlight=#5c56ae3b4e9a5a42c2780334b6a8c68c class=figure><img src=registry_hunter_remapping.png alt="Remapping the registry accessor"></div><figcaption>Remapping the registry accessor</figcaption></figure></p><p>The rules, however, don&rsquo;t really need to know about this - they just
assume they can access the whole registry using the <code>registry</code>
accessor. For example, when a rule accesses the key
<code>HKEY_USERS\Administrator\Software</code>, the key will be automatically
parsed from the <code>Software</code> hive at <code>C:\Users\Administrator\NTUSER.dat</code></p><p>Depending on the remapping strategy some hives will be directly
accessible with the API, or remapped from raw registry hives:</p><ul><li><code>API</code>: This strategy uses the API for most hives, except the
<code>HKEY_LOCAL_MACHINE\Security</code> hive which is normally blocked with
the API. Additionally, the <code>SAM</code> is mounted under <code>/SAM</code> and
<code>Amcache</code> under <code>/Amcache</code> since these are not usually accessible
via the API.<ul><li>This strategy will not be able to see users who are not logged
in, as it does not map the <code>ntuser.dat</code>.</li><li>Using the API is a bit faster than parsing the raw reg hives so
this is recommended for frequent parsing or where performance is
important.</li></ul></li><li><code>API And NTUser.dat</code>: This strategy uses the API as above, except it
also maps all the user&rsquo;s <code>ntuser.dat</code> files under the <code>/HKEY_USERS</code>
key.</li><li><code>Raw Hives</code>: This strategy does not use the API, and instead maps
all raw hives into the same <code>registry</code> accessor namespace.</li></ul><p>The default remapping strategy is <code>API And NTUser.dat</code> which is
suitable for direct remote collections. If you are collecting this
artifact on a dead-disk mount you will need to use the <code>Raw Hives</code>
strategy to direct all registry API calls to raw registry parsing.</p><h3 id=importing-the-latest-version-of-the-registry-hunter-artifact>Importing the latest version of the Registry Hunter artifact
<a class=anchor href=#importing-the-latest-version-of-the-registry-hunter-artifact>#</a></h3><p>To use the artifact you will need to import it into the server by
collecting the <code>Server.Import.RegistryHunter</code> server artifact. This
ensures you have the latest version.</p><h3 id=collecting-the-artifact>Collecting the artifact
<a class=anchor href=#collecting-the-artifact>#</a></h3><p>When collecting the artifact from a remote system, you will be able to
select which rule categories to collect - by default all rules are
collected. The default remapping strategy is also selected here.</p><p><figure id=758cb6a791e24709a2114ee8b49ffcf5><div data-featherlight=#758cb6a791e24709a2114ee8b49ffcf5 class=figure><img src=hunting_the_registry.png alt="Hunting the registry"></div><figcaption>Hunting the registry</figcaption></figure></p><h3 id=the-rule-format>The Rule format
<a class=anchor href=#the-rule-format>#</a></h3><p>Rules are specified as simple YAML clauses in a rule file. Here is the
rule that specifies the <code>SysInternals EULA</code> detection.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>Author</span>: <span style=color:#ae81ff>Andrew Rathbun</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>Description</span>: <span style=color:#ae81ff>Sysinternals</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>Category</span>: <span style=color:#ae81ff>Installed Software</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>Comment</span>: <span style=color:#ae81ff>Displays all SysInternals Tools that had the EULA accepted, indicating</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>either execution of the tool or the Registry values were added intentionally prior</span>
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>to execution</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>Glob</span>: <span style=color:#e6db74>&#39;*\SOFTWARE\Sysinternals\*\EulaAccepted&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>Root</span>: <span style=color:#ae81ff>HKEY_USERS</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>Filter</span>: <span style=color:#ae81ff>NOT IsDir</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>Details</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    x=&gt;dict(Program=x.OSPath[-2], FirstRunTimestamp=x.Mtime)</span>
</span></span></code></pre></div><p>The search glob is split into a glob part and a <code>Root</code> part. The
<code>Root</code> refers to the place within the registry namespace where the
hive is mapped (more on this below).</p><p>The registry hunter will compile this rule into a similar query to</p><pre tabindex=0><code class=language-vql data-lang=vql>    SELECT Rule.Description AS Description,
           Rule.Category AS Category,
           OSPath, Mtime,
           eval(func=Metadata.Details) AS Details
    FROM glob(globs=Rule.Glob, root=Rule.Root, accessor=&#34;registry&#34;)
    WHERE eval(func=Rule.Filter)
</code></pre><p>This rule will search the provided glob expression on the provided
root directory looking for values (the filter <code>x=>NOT IsDir</code> captures
values and rejects keys).</p><p>Matching values will cause the <code>Details</code> function to be evaluated. The
<code>Details</code> field contains a VQL <a href=https://docs.velociraptor.app/docs/vql/#vql-lambda-functions>lambda function</a> that will be evaluated on the
found keys or values. The following values will be available:</p><ul><li><code>x.OSPath</code> contains the OSPath of the matching registry key or value</li><li><code>x.Mtime</code> contains the Modification time of the key</li></ul><p>The above example returns a dictionary documenting the program and
the modification time.</p><p><figure id=82012644468a533850bb7447d8adfd1e><div data-featherlight=#82012644468a533850bb7447d8adfd1e class=figure><img src=sysinternals_reg.png alt="Sysinternals hunt output"></div><figcaption>Sysinternals hunt output</figcaption></figure></p><p>A more complex rule is the following which assembles the <code>Most Recently Used</code> values in the <code>Run Box</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>Author</span>: <span style=color:#ae81ff>Andrew Rathbun</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>Description</span>: <span style=color:#e6db74>&#34;RunMRU: Tracks commands from the Run box in the Start menu&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>Category</span>: <span style=color:#ae81ff>Program Execution</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>Root</span>: <span style=color:#ae81ff>HKEY_USERS</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>Glob</span>: <span style=color:#e6db74>&#39;*\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>Filter</span>: <span style=color:#ae81ff>x=&gt;IsDir</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>Preamble</span>:
</span></span><span style=display:flex><span>  - |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    LET CalculateMRU(OSPath) = SELECT GetValue(OSPath=OSPath + g1) AS value
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        FROM parse_records_with_regex(accessor=&#34;data&#34;,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        file=GetValue(OSPath=OSPath + &#34;MRUList&#34;), regex=&#34;(.)&#34;)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  - |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    LET FetchKeyValues(OSPath) = to_dict(item={
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      SELECT Name AS _key, Data.value AS _value
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      FROM glob(globs=&#34;*&#34;, accessor=&#34;registry&#34;, root=OSPath)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    })</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>Details</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    x=&gt;dict(MRU=CalculateMRU(OSPath=x.OSPath).value,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            All=FetchKeyValues(OSPath=x.OSPath))</span>
</span></span></code></pre></div><p><figure id=931572f1fbd6834bbf0b3d738aac4921><div data-featherlight=#931572f1fbd6834bbf0b3d738aac4921 class=figure><img src=mru.png alt="Calculating the MRU order"></div><figcaption>Calculating the MRU order</figcaption></figure></p><p>The similar <code>RECmd Batch</code> rule actually relies on custom <code>C#</code> code to
reassemble the MRU lists. This is problematic in practice because we
would need to rebuild and redeploy compiled code to the
endpoint. Instead it is much more efficient to implement the
reassembly algorithm in VQL and include it directly in this rule.</p><p>The Registry Hunter does rely on specialized processing or specific
registry plugins and simply implements all the complex parsing
directly in VQL - allowing us to upgrade the parsers on demand without
needing to recompile any code.</p><p>Notice how the <code>Details</code> lambda rule is able to reference helper
functions defined in the <code>Preamble</code> section. This allows us to create
reusable VQL functions that can be used from many rules.</p><p>You can see many helpful VQL functions defined in the preamble of the
common rule sets.</p><h2 id=presenting-the-results-of-the-analysis>Presenting the results of the analysis
<a class=anchor href=#presenting-the-results-of-the-analysis>#</a></h2><p>The Registry Hunter is designed to be a one shot, collect everything
type of artifact. This allows investigators to simply use it in all
cases and just view relevant results depending on their needs.</p><p>To facilitate this use, the artifact creates a custom notebook
breaking the results by category. The user can then begin examining
the hits for each category that is relevant to the case.</p><p><figure id=688e43f91aba6df86d0b45e1f9ebd103><div data-featherlight=#688e43f91aba6df86d0b45e1f9ebd103 class=figure><img src=initial_notebook.png alt="Initial notebook"></div><figcaption>Initial notebook</figcaption></figure></p><p>For example, suppose I was interested in anything that was related to
<code>PsExec</code>, I would write a notebook query of the form:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> Description, Category, OSPath <span style=color:#66d9ef>AS</span> <span style=color:#66d9ef>Key</span>, Mtime, Details <span style=color:#66d9ef>FROM</span> <span style=color:#66d9ef>source</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>WHERE</span> Details <span style=color:#f92672>=~</span> <span style=color:#e6db74>&#34;psexec&#34;</span>
</span></span></code></pre></div><p><figure id=d6440405035ccfdaf99ff87f66a22b85><div data-featherlight=#d6440405035ccfdaf99ff87f66a22b85 class=figure><img src=hunting_for_psexec.png alt="Isolating all psexec information"></div><figcaption>Isolating all psexec information</figcaption></figure></p><p>This query will show all information that is vaguely related to
<code>PsExec</code>, we see a number of corroborating evidence from the different
Rules:</p><ol><li><code>Userassist</code>, <code>AppCompatCache</code> and <code>Sysinternals</code> rule all match</li><li>We can see when the program was initially installed, last used and
other interesting information.</li><li>Note that here we collect multiple related results from multiple
categories.</li></ol><h2 id=current-categories>Current Categories
<a class=anchor href=#current-categories>#</a></h2><p>The following are the current categories used. When adding new rules,
please try to stick to these categories. In future this list may
evolve and consolidate:</p><ul><li>Antivirus</li><li>Autoruns</li><li>Cloud Storage</li><li>Devices</li><li>Event Logs</li><li>Executables</li><li>Installed Software</li><li>Microsoft Exchange</li><li>Microsoft Office</li><li>Network Shares</li><li>Program Execution</li><li>Services</li><li>System Info</li><li>Third Party Applications</li><li>Threat Hunting</li><li>User Accounts</li><li>User Activity</li><li>Volume Shadow Copies</li><li>Web Browsers</li></ul><h2 id=conclusions>Conclusions
<a class=anchor href=#conclusions>#</a></h2><p>The Registry Hunter is an unified artifact that compiles separate
rules hunting in the registry into a single, easy to collect and very
fast artifact. Long term we aim to consolidate all the discrete
registry based artifacts into this one artifact.</p><p>We would really love to hear feedback or see contributions to the
Registry Hunter through our GitHub repository
<a href=https://github.com/Velocidex/registry_hunter/>https://github.com/Velocidex/registry_hunter/</a> and issue board. But you
can start using it right now if you would love to test it.</p><div class="mynotices warning"><div heading=warning><p>The Registry Hunter uses newer VQL features available since release
0.72 and so will only work on clients newer than that version.</p></div></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#velociraptor-artifacts>Velociraptor Artifacts</a></li><li><a href=#some-problems-with-the-above-approach>Some problems with the above approach</a></li><li><a href=#what-do-other-tools-do>What do other tools do?</a></li><li><a href=#so-what-do-we-actually-want>So what do we actually want?</a></li><li><a href=#the-registry-hunter>The Registry Hunter</a><ul><li><a href=#remapping-the-registry-hives>Remapping the registry hives</a></li><li><a href=#importing-the-latest-version-of-the-registry-hunter-artifact>Importing the latest version of the Registry Hunter artifact</a></li><li><a href=#collecting-the-artifact>Collecting the artifact</a></li><li><a href=#the-rule-format>The Rule format</a></li></ul></li><li><a href=#presenting-the-results-of-the-analysis>Presenting the results of the analysis</a></li><li><a href=#current-categories>Current Categories</a></li><li><a href=#conclusions>Conclusions</a></li></ul></nav></div></aside></main></body></html>