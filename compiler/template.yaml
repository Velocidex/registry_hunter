name: {{.Name}}
description: |
   This artifact parses and categorizes information for the registry.

   Build time: {{ .Time }}

   Read more about this artifact here https://github.com/Velocidex/registry_hunter

   ## Collecting only few rules

   This artifact contains thousands of rules and by default performs
   deep registry analysis. If you do not need to apply all the rules,
   simply navigate to:

     https://registry-hunter.velocidex.com/docs/rules/

   Select the rule you want and add the description to the
   `DescriptionFilter` parameter below.

   ## RemappingStrategy

   In order to present a unified view of all registry hives we remap various
   hives we remap various hives into the "registry" accessor. There are a
   number of strategies implemented for this:

   1. API - This strategy uses the API for the majority of hives including
      user hives. Therefore users who are not currently logged in will not
      have their NTUser.dat hives mounted.
   2. API And NTUser.dat - This strategy uses the API for most of the hives,
      except for all the raw user hives will be mapped in HKEY_USERS.
      Therefore all users will be visible.
   3. Raw Hives - This stragegy is most suitable for working off an image or
      acquired hive files. All raw hives will be mapped (include SYSTEM, SOFTWARE etc).

   Using the API will result in faster collection times, but may be some
   differences:

   * Some registry keys are blocked with API access, even for the system
     user - so we get permission denied for these. Therefore, even with the API
     stragegy above we remap the raw files into the "raw_registry" accessor.
     The rule may work around this by using this accessor directly.
   * Some hive files are not accessible and can only be accessible using the
     API (e.g. the BCD hives).

   ## CollectionPolicy

   Some rules attempt to resolve links to other files on the disk. For
   example, category `Autoruns` may attempt to resolve the actual
   binaries being launched. These targets may be collected according
   to the `CollectionPolicy`. By default targets are not
   resolved. However, you may specify that unsigned binaries be
   collected (uploaded to the server), or other files (e.g. a `lnk`
   file).

parameters:
- name: Categories
  type: multichoice
  default: |
   {{ .CategoriesJSON }}
  choices:
   {{- range $val := .Categories }}
    - "{{ $val }}"
   {{- end }}
- name: RuleFilter
  type: regex
  default: .

- name: CollectionPolicy
  description: |
    Extracted targets will be collected using this policy.
  type: choices
  choices:
    - ExcludeSigned
    - HashOnly
    - AllFiles
    - None
  default: HashOnly

- name: MaxFileSize
  type: int
  description: |
    The max size in bytes of the individual files to upload (Default 100mb).

- name: MaxHashSize
  type: int
  description: |
    The max size in bytes of the individual files to hash (default 100mb).

- name: RemappingStrategy
  description: |
     In order to present a unified view of all registry hives we remap various hives
     into the "registry" accessor. This setting controls the strategy we use to do so.
     See more information in the artifact description.
  type: choices
  default: "API And NTUser.dat"
  choices:
   - API
   - API And NTUser.dat
   - Raw Hives
   - None

- name: TrustedPathRegex
  type: regex
  default: ^C:\\Windows\\
  description: Do not hash or upload any files matching this regex.

- name: RootDrive
  default: C:/
  description: |
     Path to the top level drive. If one of the PathTO* parameters are not
     specified, then we use this to figure out the usual paths to the hives.

- name: AlsoUploadHives
  type: bool
  description: If checked, we also upload all the hives.

- name: DEBUG
  type: bool
  description: Add more logging.

implied_permissions:
- IMPERSONATION

export: |
    LET _info <= SELECT * FROM info()
    LET S = scope()
    LET RootFilter <= S.RootFilter || "."
    LET NTFS_CACHE_TIME <= S.NTFS_CACHE_TIME || 1000000
    LET CollectionPolicy <= S.CollectionPolicy || "ExcludeSigned"
    LET RemappingStrategy <= S.RemappingStrategy || "API And NTUser.dat"

    LET CollectionPolicy <= if(condition=RemappingStrategy =~ "API",
      then= CollectionPolicy,
      else=log(message="CollectionPolicy set to None as RemappingStrategy strategy is not API based") && "None")

    LET MaxFileSize <= S.MaxFileSize || 100000000
    LET MaxHashSize <= S.MaxHashSize || 100000000

    LET _ <= log(message="MaxFileSize %v, MaxHashSize %v", args=[ MaxFileSize, MaxHashSize])

    // In ExcludeSigned and HashOnly we dont upload signed binaries.
    LET ShouldUploadSignedBinary <= dict(
       ShouldUpload = NOT CollectionPolicy =~ "ExcludeSigned|HashOnly")

    // In HashOnly mode we never upload anything.
    LET ShouldUploadAnyFile <= dict(
       ShouldUpload = NOT CollectionPolicy =~ "HashOnly|None")

    LET DoNotUpload <= dict(ShouldUpload=FALSE)

    // Upload the file if ShouldUpload marks it ready for upload.
    LET MaybeUpload(OSPath, Details) = if(
      condition=Details.Stat AND Details.ShouldUpload,
      then=Details + dict(Upload=upload(file=OSPath)),
      else=Details)

    // Determine if we should upload the file based on signature.
    LET ShouldUpload(Details) = if(
      condition= OSPath =~ TrustedPathRegex OR
                 NOT Details.Stat.Size OR
                 ( MaxFileSize > 0 AND Details.Stat.Size > MaxFileSize ),
      then= Details + DoNotUpload,
      else=if(
       // What to do about binaries? If they have an issuer name then
       // they are signed.
       condition=Details.Signatures.IssuerName,
       then=Details + ShouldUploadSignedBinary,
       else=Details + ShouldUploadAnyFile))

    // If the file is a binary, also add authenticode information.
    LET MaybeBinary(OSPath, Details) = ShouldUpload(Details=if(
       condition=Details.Magic =~ "PE.+executable",
       then=Details + dict(Signatures=authenticode(filename=OSPath)),
       else=Details))

    // Hash the file if it is not too large
    LET MaybeHash(OSPath, Details) = if(
      condition=Details.Stat AND Details.Stat.Size < MaxHashSize
                AND NOT OSPath =~ TrustedPathRegex,
      then=Details + dict(Hashes=hash(path=OSPath),
                          Magic=magic(path=OSPath)),
      else=Details)

    // Calculate the details column with hashes and magic.
    LET _GetDetails(OSPath) = if(
    condition= CollectionPolicy =~ "None" OR NOT OSPath.Components,
    then=dict(),
    else=MaybeUpload(OSPath=OSPath, Details=MaybeBinary(
      OSPath=OSPath,
      Details=MaybeHash(OSPath=OSPath,
           Details=dict(filename=OSPath, Stat=OSPath &&
              log(message="Checking file %v", args=OSPath, dedup= -1) &&
              stat(filename=OSPath))))))

    LET GetDetails(OSPath) = cache(period=10000,
       func= _GetDetails(OSPath=pathspec(parse=OSPath, path_type="windows")),
       name="GetDetails", key=str(str=OSPath))

    -- This contains the metadata for Glob rules.
    LET _MD <= parse_json_array(data=gunzip(string=base64decode(string="{{.Metadata }}")))
    LET MD(DescriptionFilter, RootFilter, CategoryFilter, CategoryExcludedFilter) =
     SELECT Glob, Category, Description,
            get(field="Details") AS Details,
            get(field="Comment") AS Comment,
            get(field="Filter") AS Filter, Root
     FROM _MD
     WHERE Description =~ DescriptionFilter
       AND Root =~ RootFilter
       AND Category =~ CategoryFilter
       AND NOT Category =~ CategoryExcludedFilter

    -- On Non Windows systems we need to use case insensitive accessor or we might not find the right hives.
    LET DefaultAccessor <= if(condition=_info[0].OS =~ "windows", then="ntfs", else="file_nocase")
    LET HKLM <= pathspec(parse="HKEY_LOCAL_MACHINE", path_type="registry")
    LET RootDrive <= pathspec(Path=S.RootDrive || "C:/")
    LET PathTOSAM <= S.PathTOSAM || RootDrive + "Windows/System32/config/SAM"
    LET PathTOAmcache <= S.PathTOAmcache || RootDrive + "Windows/appcompat/Programs/Amcache.hve"
    LET PathTOSystem <= S.PathTOSystem || RootDrive + "Windows/System32/Config/System"
    LET PathTOSecurity <= S.PathTOSecurity || RootDrive + "Windows/System32/Config/Security"
    LET PathTOSoftware <= S.PathTOSoftware || RootDrive + "Windows/System32/Config/Software"
    LET PathTOUsers <= S.PathTOUsers || RootDrive + "Users/"

    -- HivePath: The path to the hive on disk
    -- RegistryPath: The path in the registry to mount the hive
    -- RegMountPoint: The path inside the hive to mount (usually /)
    LET _map_file_to_reg_path(HivePath, RegistryPath, RegMountPoint, Accessor, Description) = dict(
       type="mount", description=Description,
       `from`=dict(accessor='raw_reg',
                   prefix=pathspec(
                      Path=RegMountPoint,
                      DelegateAccessor=Accessor,
                      DelegatePath=HivePath),
                   path_type='registry'),
        `on`=dict(accessor='registry',
                  prefix=RegistryPath,
                  path_type='registry'))

    LET _standard_mappings = (
       _map_file_to_reg_path(
          HivePath=PathTOSystem,
          RegistryPath="HKEY_LOCAL_MACHINE\\System\\CurrentControlSet",
          RegMountPoint="/ControlSet001",
          Accessor=DefaultAccessor,
          Description="Map SYSTEM Hive to CurrentControlSet"),
       _map_file_to_reg_path(
          HivePath=PathTOSoftware,
          RegistryPath="HKEY_LOCAL_MACHINE\\Software",
          RegMountPoint="/",
          Accessor=DefaultAccessor,
          Description="Map Software hive to HKEY_LOCAL_MACHINE"),
       _map_file_to_reg_path(
          HivePath=PathTOSystem,
          RegistryPath="HKEY_LOCAL_MACHINE\\System",
          RegMountPoint="/",
          Accessor=DefaultAccessor,
          Description="Map System hive to HKEY_LOCAL_MACHINE"),
       _map_file_to_reg_path(
          HivePath=PathTOSecurity,
          RegistryPath="HKEY_LOCAL_MACHINE\\Security",
          RegMountPoint="/",
          Accessor=DefaultAccessor,
          Description="Map SECURITY Hive to HKEY_LOCAL_MACHINE"),
    )

    // Map raw hives for hives that are not normally accessible via API
    LET _unmounted_hive_mapping = (
      _map_file_to_reg_path(
          HivePath=PathTOSAM,
          RegistryPath="SAM",
          RegMountPoint="/",
          Accessor=DefaultAccessor,
          Description="Map SAM to /SAM/"),
      _map_file_to_reg_path(
          HivePath=PathTOAmcache,
          RegistryPath="Amcache",
          RegMountPoint="/",
          Accessor=DefaultAccessor,
          Description="Map Amcache to /Amcache/"),
    )

    LET _Env = SELECT _value FROM items(item= {
       SELECT * FROM environ()
    })

    LET _VQLEnv = SELECT dict(key=_key, value=_value) AS Items
    FROM items(item=_Env[0]._value)
    WHERE _key AND NOT _key =~ "VELOCIRAPTOR"

    LET _api_remapping <= (
        dict(type="impersonation",
            os="windows",
            hostname="RegistryMapper",
            env=_VQLEnv.Items),
        -- By default remap the entire "registry" accessor for API access.
        dict(type="mount",
          `from`=dict(accessor="registry", prefix='/', path_type='registry'),
          on=dict(accessor="registry", prefix='/', path_type="registry")),

       -- Always remap raw Security because the API stops us from reading the keys.
       _map_file_to_reg_path(
          HivePath=PathTOSecurity,
          RegistryPath="HKEY_LOCAL_MACHINE\\Security",
          RegMountPoint="/",
          Accessor=DefaultAccessor,
          Description="Map SECURITY Hive to HKEY_LOCAL_MACHINE"),
    )

    -- In API mode we sometimes can not access the keys due to permissions.
    -- These mapping ensure rules can specifically access the raw hives if they
    -- need to.
    LET _raw_hive_mapping_for_api <= (
      dict(type="mount",
        description="Map System Hive to raw_registry accessor",
        `from`=dict(accessor="raw_reg",
         prefix=pathspec(Path='/',
           DelegatePath=PathTOSystem,
           DelegateAccessor=DefaultAccessor),
         path_type='registry'),
       on=dict(accessor="raw_registry",
               prefix='/HKEY_LOCAL_MACHINE/System',
               path_type="registry")),
      dict(type="mount",
        description="Map Software Hive to raw_registry accessor",
        `from`=dict(accessor="raw_reg",
         prefix=pathspec(Path='/',
           DelegatePath=PathTOSoftware,
           DelegateAccessor=DefaultAccessor),
         path_type='registry'),
       on=dict(accessor="raw_registry",
               prefix='/HKEY_LOCAL_MACHINE/Software',
               path_type="registry")),
    )

    // The BCD hive is normally located on an unmounted drive so we
    // always map it with the API.
    LET _bcd_map <= (dict(
       type="mount",
       `from`=dict(accessor="registry", prefix='HKEY_LOCAL_MACHINE\\BCD00000000', path_type='registry'),
       on=dict(accessor="registry", prefix='HKEY_LOCAL_MACHINE\\BCD00000000', path_type="registry")))

    -- Map all the NTUser.dat files even in API mode because these are often not mounted.
    LET _map_ntuser = SELECT
    _map_file_to_reg_path(
      HivePath=OSPath,
      RegMountPoint="/",
      Accessor=DefaultAccessor,
      Description=format(format="Map NTUser.dat from User %v to HKEY_USERS",
                         args=OSPath[-2]),

      -- This is technically the SID but it is clearer to just use the username
      RegistryPath="HKEY_USERS\\" + OSPath[-2]) AS Mapping
    FROM glob(globs="*/NTUser.dat", root=PathTOUsers)

    LET _map_userclass = SELECT
    _map_file_to_reg_path(
      HivePath=OSPath,
      RegMountPoint="/",
      Accessor=DefaultAccessor,
      Description=format(
         format="Map UsrClass.dat from User %v to HKEY_USERS/%v/Software/Classes",
         args=[OSPath[2], OSPath[2]]),

      -- This is technically the SID but it is clearer to just use the username
      RegistryPath="HKEY_USERS\\" + OSPath[2] + "\\Software\\Classes") AS Mapping
    FROM glob(globs="*/AppData/Local/Microsoft/Windows/UsrClass.dat",
              root=PathTOUsers)


    LET _log_array(Message) = if(condition=log(message=Message), then=[])

    // Apply the mappings:
    LET RemapRules = if(condition=RemappingStrategy =~ "API.+NTUser",
       then=_api_remapping +
            _map_ntuser.Mapping +
            _map_userclass.Mapping +
            _unmounted_hive_mapping +
            _raw_hive_mapping_for_api  +
            _log_array(Message="Using API And NTUser.dat Mapping"),

    else=if(condition=RemappingStrategy =~ "API",
       then=_api_remapping +
            _unmounted_hive_mapping +
            _log_array(Message="Using API Mapping"),

    else=if(condition=RemappingStrategy =~ "raw hive",
       then=_map_ntuser.Mapping +
            _map_userclass.Mapping +
            _unmounted_hive_mapping +
            _standard_mappings +
            _raw_hive_mapping_for_api +
            _log_array(Message="Using Raw Hives Mapping"),
    else=log(message="Unsupported remapping strategy %v", args=RemappingStrategy))))

{{ .Preamble }}

    -- This contains the queries for Full Query Rules - they skip the glob and just run arbitrary VQL.
    LET FullQueries <= parse_json_array(data=gunzip(string=base64decode(string="{{ .QueriesJSON }}")))

    LET _ExpandedTransforms <= dict(
        `^\\\\SystemRoot\\\\`="%SystemRoot%\\",
        `^system32\\\\`="%SystemRoot%\\System32\\",
        `^{.+}.+`="\\$0",
        `^C:\\\\Program Files[^\\\\]*\\\\[^ ]+`='"$0"',
        `^%[^ ]+%[^ ]+`='"$0"'
      )

    // Extract the binary from the command line
    LET ExpandPath(Path) = lowcase(string=commandline_split(
    command=expand(path=regex_transform(source=Path,
      map=_ExpandedTransforms)))[0])

sources:
- name: Remapping
  query: |
    SELECT * FROM RemapRules

  notebook:
  - type: none

- name: Rules
  query: |
    LET CategoryFilter <= S.CategoryFilter || join(array=Categories, sep="|")
    LET AllFullQueries <=
        SELECT * FROM FullQueries
        WHERE Category =~ CategoryFilter
          AND Description =~ RuleFilter

    LET AllRules <=
      SELECT * FROM MD(DescriptionFilter=RuleFilter, RootFilter=RootFilter,
        CategoryFilter=CategoryFilter, CategoryExcludedFilter=S.CategoryExcludedFilter)

    SELECT * FROM chain(a=AllRules, b=AllFullQueries)
  notebook:
  - type: none

- name: Globs
  notebook:
  - type: none

  query: |
    LET AllGlobs <=
      SELECT Root, enumerate(items=Glob) AS Globs
      FROM AllRules
      GROUP BY Root

    SELECT * FROM AllGlobs

- name: Uploads
  notebook:
  - type: none

  query: |
   LET UploadFiles = SELECT OSPath AS SourceFile, Size,
       Btime AS Created,
       Ctime AS Changed,
       Mtime AS Modified,
       Atime AS LastAccessed,
       upload(file=OSPath, accessor=DefaultAccessor, mtime=Mtime) AS Upload
    FROM glob(accessor=DefaultAccessor, globs=[
       PathTOSAM, PathTOAmcache, PathTOSystem,
       PathTOSecurity, PathTOSoftware, PathTOUsers + "*/ntuser.dat*"
    ])

   SELECT * FROM if(condition=AlsoUploadHives, then=UploadFiles)

- name: Results
  notebook:
    - type: vql
      output: "<h1>All Results</h1>Press recalculate to View"
      template: |
         SELECT * FROM source(source="Results")

   {{- range $val := .Categories }}
    - type: vql
      output: "<h1>Category {{ $val }}</h1>Press recalculate to View"
      template: |
         /*
         # Category {{ $val }}
         */

         -- Adjust the Description Regex to focus on specific rules.
         SELECT Description, count() AS Count,
                OSPath AS Key, Mtime, Details FROM source(source="Results")
         WHERE Category = '''{{ $val }}''' AND Description =~ "."
         GROUP BY Description

   {{- end }}
  query: |
    LET CategoryFilter <= S.CategoryFilter || join(array=Categories, sep="|")
    LET AllFullQueries <=
        SELECT * FROM FullQueries
        WHERE Category =~ CategoryFilter
          AND Description =~ RuleFilter

    LET AllRules <=
      SELECT * FROM MD(DescriptionFilter=RuleFilter, RootFilter=RootFilter,
        CategoryFilter=CategoryFilter, CategoryExcludedFilter=S.CategoryExcludedFilter)

    LET AllGlobs <=
      SELECT Root, enumerate(items=Glob) AS Globs
      FROM AllRules
      GROUP BY Root

    LET GlobsMD <= to_dict(item={
      SELECT Root AS _key, Globs AS _value FROM AllGlobs
    })

    LET ShouldLog <= NOT DEBUG

    LET Cache <= memoize(query={
       SELECT Glob, Category, Description,
              Details, Filter, Comment
       FROM AllRules
       WHERE ShouldLog || log(
           message="Add to cache %v %v", args=[Glob, Description], dedup=-1)
    }, key="Glob", period=100000)

    LET _ <= RemappingStrategy =~ "none" ||
                remap(config=dict(remappings=RemapRules))

    LET Result = SELECT OSPath, Mtime,
       Data.value AS Data,
       get(item=Cache, field=Globs[0]) AS Metadata,
       Globs[0] AS _Glob,
       IsDir
    FROM foreach(row={
       SELECT _key AS Root, _value AS GlobsToSearch
       FROM items(item=GlobsMD)
       WHERE Root =~ RootFilter
         AND log(message="Will search with globs %v at Root point %v",
             dedup=-1, args=[GlobsToSearch, Root])

    }, query={
       SELECT * FROM glob(globs=GlobsToSearch, root=Root, accessor="registry")
    })
    WHERE ShouldLog || log(
          message="Glob %v OSPath %v Metadata %v",
          args=[Globs[0], OSPath, Metadata], dedup=-1)

    LET GlobRules = SELECT Metadata.Description AS Description,
           Metadata.Category AS Category,
           OSPath, Mtime, Data AS _RawData,
           eval(func=Metadata.Details || "x=>x.Data") || Data AS Details,
           Metadata AS _Metadata
    FROM Result
    WHERE eval(func=Metadata.Filter || "x=>NOT IsDir")

    SELECT * FROM chain(
    a=GlobRules,
    b={
      SELECT * FROM foreach(row=AllFullQueries, query={
        SELECT * FROM query(query=Query, inherit=TRUE)
      })
    })


column_types:
- name: Details
  type: json/1
